<form style="margin: 0; padding: 0; display: inline">
  <label for="search" style="display: none">Quick Filter:</label>
  <input id="search" name="search" class="quickfilter" type="search" 
         placeholder="Quick Filter (Press / to focus, Esc to clear)" 
         autocomplete="off" aria-describedby="search-help" />
  <div id="search-help" style="display: none;">Search portals by name, URL, or category. Use / to focus search, Esc to clear, Ctrl+K for advanced search.</div>
  
  <div class="keyboard-shortcuts" style="margin-top: 8px; font-size: 0.8em; color: #999;">
    <details style="display: inline-block;">
      <summary style="cursor: pointer; color: #b5e853;">⌨️ Shortcuts</summary>
      <div style="margin-top: 5px; padding: 8px; background: rgba(0,0,0,0.5); border-radius: 4px; position: absolute; z-index: 1000; min-width: 200px;">
        <div><kbd>/</kbd> Focus search</div>
        <div><kbd>Ctrl+K</kbd> Focus search</div>
        <div><kbd>Esc</kbd> Clear search</div>
        <div><kbd>Tab</kbd> Navigate portals</div>
        <div><kbd>Enter</kbd> Add to favorites</div>
        <div><kbd>↑↓</kbd> Navigate favorites</div>
      </div>
    </details>
  </div>
</form>

<script type="text/javascript">
  // Enhanced search with fuzzy matching
  function fuzzyMatch(text, query) {
    const textLower = text.toLowerCase();
    const queryLower = query.toLowerCase();
    
    // Exact match gets highest priority
    if (textLower.includes(queryLower)) return 3;
    
    // Fuzzy match - check if all query characters appear in order
    let textIndex = 0;
    let queryIndex = 0;
    let matches = 0;
    
    while (textIndex < textLower.length && queryIndex < queryLower.length) {
      if (textLower[textIndex] === queryLower[queryIndex]) {
        matches++;
        queryIndex++;
      }
      textIndex++;
    }
    
    if (queryIndex === queryLower.length) {
      // All query characters found in order
      const ratio = matches / queryLower.length;
      return ratio > 0.8 ? 2 : (ratio > 0.6 ? 1 : 0);
    }
    
    return 0;
  }

  function showOnlyMatchedPortals() {
    const query = this.value;
    const portalEntries = Array.from(document.querySelectorAll("div[class='portal-group'] div[class='portal']"));
    
    if (query.length >= 1) {
      const results = [];
      
      portalEntries.forEach((portalEntry) => {
        // Build searchable string including text and URLs
        let searchableString = portalEntry.innerText;
        searchableString += Array.from(portalEntry.getElementsByTagName("a"))
          .map((e) => e.href)
          .join("|");
        
        // Clean up searchable string
        searchableString = searchableString
          .replace(/(https|http):\/\//gi, "")
          .replace(/\n/g, "|");
        
        const matchScore = fuzzyMatch(searchableString, query);
        
        if (matchScore > 0) {
          results.push({ element: portalEntry, score: matchScore });
          // Show matching portal
          Array.from(portalEntry.getElementsByTagName("*")).forEach((elem) => {
            elem.hidden = false;
          });
        } else {
          // Hide non-matching portal
          Array.from(portalEntry.getElementsByTagName("*")).forEach((elem) => {
            elem.hidden = true;
          });
        }
      });
      
      // Sort results by match score (higher scores first)
      results.sort((a, b) => b.score - a.score);
      
    } else {
      // Show all portals when query is empty
      portalEntries.forEach((portalEntry) => {
        Array.from(portalEntry.getElementsByTagName("*")).forEach((elem) => {
          elem.hidden = false;
        });
      });
    }

    // Handle portal groups visibility
    Array.from(document.querySelectorAll("div[class='portal-group']")).forEach((portalGroup) => {
      const visiblePortals = Array.from(portalGroup.querySelectorAll(".portal *")).filter(
        elem => !elem.hidden
      ).length;
      
      portalGroup.hidden = visiblePortals === 0;
    });

    // Display "no matches" message
    const totalVisibleGroups = Array.from(document.querySelectorAll("div[class='portal-group']"))
      .filter(group => !group.hidden).length;
    
    const noMatchesElement = document.getElementsByClassName("nomatches")[0];
    if (noMatchesElement) {
      noMatchesElement.style.display = totalVisibleGroups === 0 ? "block" : "none";
    }
  }

  // Keyboard shortcuts
  document.addEventListener('keydown', function(e) {
    const searchInput = document.getElementById('search');
    
    // Press "/" to focus search (like GitHub)
    if (e.key === '/' && document.activeElement !== searchInput) {
      e.preventDefault();
      searchInput.focus();
      searchInput.select();
    }
    
    // Escape to clear search and blur
    if (e.key === 'Escape' && document.activeElement === searchInput) {
      searchInput.value = '';
      searchInput.blur();
      showOnlyMatchedPortals.call(searchInput);
    }
    
    // Ctrl+K or Cmd+K to focus search (like VS Code)
    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
      e.preventDefault();
      searchInput.focus();
      searchInput.select();
    }
  });

  function idleSave() {
    var t;

    function saveSearchParamToHistory() {
      const qfInput = document.querySelector("#search");
      writeSearchToHistory.call(qfInput);
    }
    window.onload = resetIdleTimer;
    window.onmousemove = resetIdleTimer;
    window.onmousedown = resetIdleTimer; // catches touchscreen presses as well
    window.ontouchstart = resetIdleTimer; // catches touchscreen swipes as well
    window.onclick = resetIdleTimer; // catches touchpad clicks as well
    window.onkeydown = resetIdleTimer;
    window.addEventListener("scroll", resetIdleTimer, true); // improved; see comments

    function resetIdleTimer() {
      clearTimeout(t);
      t = setTimeout(saveSearchParamToHistory, 5000); // time is in milliseconds
    }
    function writeSearchToHistory() {
      let theURL = new URL(window.location.toString());
      theURL.search = window.location.search.substring(1); // copy current search-parameters without the '#' AS search-parameters
      theURL.searchParams.set("search", this.value);

      if (window.location.toString() !== theURL.href) {
        window.history.replaceState({}, "", theURL.href);
      }
    }
  }
  idleSave();

  window.onload = function () {
    // Select Search Box Element
    const qfInput = document.querySelector("#search");

    // Fill Search Box with URL Search value
    let theURL = new URL("https://dummy.com");
    // create dummy url
    theURL.search = window.location.search.substring(1);
    // copy current search-parameters without the '#' AS search-parameters
    qfInput.value = theURL.searchParams.get("search");

    // Add Event Listeners for changes (After we set the search box value)
    qfInput.addEventListener("change", showOnlyMatchedPortals);
    qfInput.addEventListener("keyup", showOnlyMatchedPortals);
    qfInput.focus({
      preventScroll: true,
    });
    // Place Cursor in the search box, ready to type

    // Create Promise to resolve after initial filtering is done
    var loadScriptAsync = function () {
      return new Promise((resolve, reject) => {
        showOnlyMatchedPortals.call(qfInput);
        resolve();
      });
    };
    var scriptLoaded = loadScriptAsync();
    scriptLoaded.then(function () {
      if (window.location.hash != "") {
        document.querySelectorAll(window.location.hash).forEach(function (anchorLink) {
          if (anchorLink.parentNode.hidden === false) {
            anchorLink.scrollIntoView({
              preventScroll: true,
              behavior: "smooth",
              block: "start",
            });
          }
        });
      }
    });
  };
</script>
